\subsubsection{网络流割点}
网络流求割点：将一个点拆成两个点，两个点之间连一条边。求出最大流后，从源点开始DFS遍历，如果一条边没有满流就可以通过，记录源点S可以到达的点。如果一条边是割边，则这条边的两个点分别属于S集合和T集合。
\begin{verbatim}
procedure dfs(x:longint); //从原点开始遍历f[p]>0的边，得到S点集。。。
var
    p,y:longint;
begin
    p:=last[x];
    repeat
        y:=adj[p];
        if (f[p]>0) and (not visit[y]) then
        begin
            visit[y]:=true;
            dfs(y);
        end;
        p:=next[p];
        if p=0 then p:=g[x];
    until p=last[x];
end;

procedure slove;    //枚举S点集，找出与S点集连边中满流的边。。。
var
    i,j,p,y:longint;
begin
    ans[0]:=0;
    for i:=1 to 2*n do
        if visit[i] then
        begin
            p:=last[i];
            repeat
                y:=adj[p];
                if ((f[p]=0) and (c[p]<>0)) and (not visit[y]) then
                begin
                    inc(ans[0]);
                    ans[ans[0]]:=i;
                    break;
                end;
                p:=next[p];
                if p=0 then p:=g[i];
            until p=last[i];
        end;
    for i:=1 to ans[0] do
    begin
        if i<>1 then write(' ');
        write(ans[i]);
    end;
    writeln;
end;
\end{verbatim} 
