\subsubsection{KM算法}
\begin{verbatim}
function Find(k:integer):boolean;
var
  i:integer;
begin
  sx[k]:=true;
  for i:=1 to m do
    if (not sy[i]) and (lx[k]+ly[i]=g[k,i]) then
    begin
      sy[i]:=true;
      if (cy[i]=0) or (Find(cy[i])) then
      begin
        cx[k]:=i;
        cy[i]:=k;
        exit(true);
      end;
    end;
  exit(false);
end;

function Max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;

function Min(a,b:longint):longint;
begin
  if a>b then exit(b) else exit(a);
end;

procedure main;
var
  i,j,k,tmp:longint;
begin
  fillchar(cx,sizeof(cx),0);
  fillchar(cy,sizeof(cy),0);
  fillchar(lx,sizeof(lx),0);
  fillchar(ly,sizeof(ly),0);
  for i:=1 to n do
    for j:=1 to m do
      lx[i]:=Max(lx[i],g[i,j]);
  for k:=1 to n do
    if cx[k]=0 then
    while true do
    begin
      fillchar(sx,sizeof(sx),0);
      fillchar(sy,sizeof(sy),0);
      if Find(k) then break;
      tmp:=Maxlong;
      for i:=1 to n do
        if sx[i] then
          for j:=1 to m do
            if not sy[j] then
              tmp:=Min(tmp,lx[i]+ly[j]-g[i,j]);
      for i:=1 to n do
        if sx[i] then lx[i]:=lx[i]-tmp;
      for i:=1 to m do
        if sy[i] then ly[i]:=ly[i]+tmp;
    end;
  ans:=0;
  for i:=1 to n do
    ans:=ans+g[i,cx[i]];
  writeln(ans);
end;
\end{verbatim}
